#!@PERL@
## Copyright (C) 2016 Robert Krawitz
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Compress 

use strict;

# Compression levels (cumulative):
#
# 0 - none
# 1 - elide duplicate hashes
# 2 - use global minimum hash length prefix
# 3 - use pairwise minimum hash length prefix
# 4 - use substitution table for common option names
# 5 - common prefix/suffix elimination for chunks
# 6 - pack multiple consecutive identical chunks
# 7 - eliminate BW/color prefix
# 8 - replace space (inter-record gaps) with high bit set on last byte
# 9 - compact subexpression elimination (5 and 6)

my ($comp_level) = 9;

my (%checksums);

my (@ptable) =
    (["=\\+", pack("C", 27)],
     ["!\\+", pack("C", 26)],
     ['"\+', pack("C", 25)],
     [",\\+", pack("C", 24)],
     ["'\\+", pack("C", 23)],
     ["%\\+", pack("C", 22)],
     [">\\+", pack("C", 21)],
     ["20\\+", pack("C", 20)],
     ["19\\+", pack("C", 19)],
     ["18\\+", pack("C", 18)],
     ["17\\+", pack("C", 17)],
     ["16\\+", pack("C", 16)],
     ["15\\+", pack("C", 15)],
     ["14\\+", pack("C", 14)],
     ["13\\+", pack("C", 13)],
     ["12\\+", pack("C", 12)],
     ["11\\+", pack("C", 11)],
     ["10\\+", pack("C", 9)],	# 0xa is newline!
     ["9\\+", pack("C", 8)],
     ["8\\+", pack("C", 7)],
     ["7\\+", pack("C", 6)],
     ["6\\+", pack("C", 5)],
     ["5\\+", pack("C", 4)],
     ["4\\+", pack("C", 3)],
     ["3\\+", pack("C", 2)],
     ["2\\+", pack("C", 1)]);

my $psub_code = '';
foreach my $psub (@ptable) {
    $psub_code .= "    \$out =~ s/$$psub[0]/$$psub[1]/g;\n";
}

my (%sub_table) = (
    "PrintingMode" => "P;",
    "PageSize" => "S;",
    "DitherAlgorithm" => "D;",
    "Resolution" => "R;",
    "ColorCorrection" => "C;",
    "Color" => "c;",
    "MediaType" => "M;",
    "InputSlot" => "I;"
    );

my ($spc) = unpack("C", " ");

sub compress_chunk($) {
    my ($chunk) = @_;
    if (defined $sub_table{$chunk}) {
	return $sub_table{$chunk};
    } else {
	return $chunk;
    }
}

sub find_min_nonunique_prefix(@) {
    my (@sums) = sort @_;
    my ($last) = "";
    my ($max_prefix) = 0;
    my ($lc) = 0;

    foreach my $sum (@sums) {
	$lc++;
	if ($last eq "") {
	    $last = $sum;
	    next;
	}
	foreach my $l ($max_prefix..length $sum) {
	    if (substr($sum, 0, $l) eq substr($last, 0, $l)) {
		$max_prefix++;
	    } else {
		next;
	    }
	}
	$last = $sum;
    }
    return $max_prefix;
}

sub min($$) {
    my ($a, $b) = @_;
    if ($a < $b) {
	return $a;
    } else {
	return $b;
    }
}

sub get_printer($) {
    my ($mode) = @_;
    $mode =~ s/_PrintingMode.*//;
    return $mode;
}

sub get_mode($) {
    my ($mode) = @_;
    $mode =~ s/.*_PrintingMode/PrintingMode/;
    return $mode;
}

if ($comp_level == 0) {
    while (<>) {
	print;
    }
    exit;
}

while (<>) {
    chomp;
    my ($sum, @keys) = split;
    my (@pchunks) = ();
    foreach my $k (@keys) {
	my (@chunks) = split(/_/, $k, -1);
	foreach my $i (0..$#chunks) {
	    if ($chunks[$i] eq '') {
		$chunks[$i] = $pchunks[$i];
	    } elsif ($chunks[$i] =~ /^([0-9]+)\+(.*)/) {
		$chunks[$i] = substr($pchunks[$i], 0, $1) . $2;
	    }
	}
	my $key = join('_', @chunks), '.prn';
	if (! defined $checksums{$sum}) {
	    $checksums{$sum} = [];
	}
	push @{$checksums{$sum}}, $key;
    }
}

my $min_prefix;

if ($comp_level > 1) {
    $min_prefix = find_min_nonunique_prefix(keys %checksums);
} else {
    $min_prefix = length((keys %checksums)[0]);
}

my ($last_sum) = "";

foreach my $sum (sort keys %checksums) {
    my ($out) = substr($sum, 0, $min_prefix);
    if ($last_sum ne "" && $comp_level > 2) {
	$out = substr($out, find_min_nonunique_prefix($sum, $last_sum) - 1);
    }
    $last_sum = $sum;
    my ($prun) = "";
    my (@pchunks) = ();
    my ($plen) = 0;
    my (@runs) = sort map {
	s/^\*//;
	s/\.prn$//;
	my ($printer) = get_printer($_);
	my ($mode) = get_mode($_);
	"${mode}_:$printer"
    } @{$checksums{$sum}};
    my ($lastdup) = 0;
    foreach my $run (@runs) {
	my (@chunks) = split(/[_]/, $run);
	if ($comp_level > 3) {
	    @chunks = map { compress_chunk($_) } @chunks;
	}
	my ($mchunks) = min(scalar @pchunks, scalar @chunks);
	my ($i) = 0;
	$out .= " ";
	while ($i < $mchunks) {
	    if ($i > 0) {
		$out .= '_';
	    }
	    if ($chunks[$i] ne $pchunks[$i]) {
		if ($comp_level > 4) {
		    my ($plen) = length $pchunks[$i];
		    my ($len) = length $chunks[$i];
		    my ($maxc) = min($len, $plen);
		    my ($dup) = 0;
		    my ($tail) = 0;
		    while ($dup < $maxc) {
			last if (substr($pchunks[$i], $dup, 1) ne
				 substr($chunks[$i], $dup, 1));
			$dup++;
		    }
		    while ($tail < $maxc - $dup) {
			last if (substr($pchunks[$i], -1 - $tail, 1) ne
				 substr($chunks[$i], -1 - $tail, 1));
			$tail++;
		    }
		    my ($chunk) = $chunks[$i];
		    if ($tail == 2) {
			$chunk = substr($chunk, 0, -$tail) . '\\';
		    } elsif ($tail > 2) {
			$chunk = substr($chunk, 0, -$tail) . "/$tail";
		    }
		    if ($dup == 2) {
			$out .= '*' . substr($chunk, $dup);
		    } elsif ($dup > 2) {
			if ($dup == $lastdup) {
			    $out .= "+" . substr($chunk, $dup);
			} else {
			    $out .= "$dup+" . substr($chunk, $dup);
			}
		    } else {
			$out .= "$chunk";
		    }
		    $lastdup = $dup;
		} else {
		    $out .= $chunks[$i];
		}
	    }
	    $i++;
	}
	if ($i < scalar @chunks) {
	    if ($i > 0) {
		$out .= '_';
	    }
	    $out .= join("_", @chunks[$i..$#chunks]);
	}
	@pchunks = @chunks;
    }
    if ($comp_level > 5) {
	$out =~ s/________/=/g;
	$out =~ s/_______/!/g;
	$out =~ s/______/"/g;
	$out =~ s/_____/,/g;
	$out =~ s/____/'/g;
	$out =~ s/___/%/g;
	$out =~ s/__/>/g;
    }
    if ($comp_level > 6) {
	$out =~ s/^([0-9a-f]+ )P;_BW_/$1./;
	$out =~ s/^([0-9a-f]+ )P;_c;_/$1,/;
    }
    if ($comp_level > 7) {
	my (@bytes) = unpack("C*", $out);
	my (@nbytes) = $bytes[0];
	foreach my $i (1..$#bytes) {
	    if ($bytes[$i] == $spc) {
		$nbytes[$#nbytes] += 128;
	    } else {
		push @nbytes, $bytes[$i];
	    }
	}
	$out = pack("C*", @nbytes);
    }
    if ($comp_level > 8) {
	eval $psub_code;
    }
    print "$out\n";
}
